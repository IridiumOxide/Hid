module Interpreter where

-- Haskell module generated by the BNF converter

import AbsHid
import ErrM
import Control.Monad
import Control.Monad.Except
import Control.Monad.State
import Control.Monad.Writer
import Data.Map

data Value = ValInt Integer | ValGeorge Bool deriving (Show, Eq, Ord)
type Var = String
type Loc = Integer

data EnvThing = Loc Loc deriving Show
type Env = Map Var EnvThing
type Store = Map Loc Value
data MyState = MyState {env :: Env, store :: Store} deriving Show

type MyMonad = ExceptT String (WriterT [String] (State MyState))

type Result = MyMonad

emptyMyState :: MyState
emptyMyState = MyState {env = empty, store = empty}

applyBoolOperator :: Exp -> Exp -> (Value -> Value -> Bool) -> Result Value
applyBoolOperator exp1 exp2 f = do
  v1 <- transExp exp1
  v2 <- transExp exp2
  return (ValGeorge (f v1 v2))

applyIntOperator :: Exp -> Exp -> (Integer -> Integer -> Integer) -> Result Value
applyIntOperator exp1 exp2 f = do
  v1 <- transExp exp1
  v2 <- transExp exp2
  return (ValInt (let {ValInt x1 = v1; ValInt x2 = v2} in f x1 x2))

failure :: a -> Result Value
failure x = do
  throwError "Not implemented!"
  return (ValInt 0)

transMyIdent :: MyIdent -> Result Value
transMyIdent x = case x of
  MyIdent string -> failure x
transProgram :: Program -> Result ()
transProgram x = case x of
  Prog codes -> do
    return ()
transCode :: Code -> Result Value
transCode x = case x of
  FCode function -> failure x
  SCode stm -> failure x
transFunction :: Function -> Result Value
transFunction x = case x of
  Fun type_ myident decls stms -> failure x
transDecl :: Decl -> Result Value
transDecl x = case x of
  Dec type_ myidents -> failure x
transStm :: Stm -> Result Value
transStm x = case x of
  SDecl decl -> failure x
  SExp exp -> failure x
  SBlock stms -> failure x
  SWhile exp stm -> failure x
  SReturn exp -> failure x
  SIf exp stm -> failure x
  SIfElse exp stm1 stm2 -> failure x
  SFor exp1 exp2 exp3 stm -> failure x
  SPrt exp -> failure x
transExp :: Exp -> Result Value
transExp x = case x of
  EAss myident assignop exp -> failure x
  ELt exp1 exp2 -> applyBoolOperator exp1 exp2 (<)
  EGt exp1 exp2 -> applyBoolOperator exp1 exp2 (>)
  ELe exp1 exp2 -> applyBoolOperator exp1 exp2 (<=)
  EGe exp1 exp2 -> applyBoolOperator exp1 exp2 (>=)
  EEq exp1 exp2 -> applyBoolOperator exp1 exp2 (==)
  ENeq exp1 exp2 -> applyBoolOperator exp1 exp2 (/=)
  EAdd exp1 exp2 -> applyIntOperator exp1 exp2 (+)
  ESub exp1 exp2 -> applyIntOperator exp1 exp2 (-)
  EMul exp1 exp2 -> applyIntOperator exp1 exp2 (*)
  EDiv exp1 exp2 -> applyIntOperator exp1 exp2 (div)
  EInc exp -> do
    v <- transExp exp
    return (ValInt (let ValInt x = v in x + 1))
  EDec exp -> do
    v <- transExp exp
    return (ValInt (let ValInt x = v in x - 1))
  EUmin exp -> do
    v <- transExp exp
    return (ValInt (let ValInt x = v in -x))
  ENeg exp -> do
    v <- transExp exp
    return (ValGeorge (let ValGeorge b = v in not b))
  EPreIn myident -> failure x
  EPreDe myident -> failure x
  EPstIn myident -> failure x
  EPstDe myident -> failure x
  Call myident exps -> failure x
  EVar myident -> failure x
transAssignOp :: AssignOp -> Result Value
transAssignOp x = case x of
  Assign -> failure x
  AssignAdd -> failure x
  AssignSubt -> failure x
  AssignMult -> failure x
  AssignDiv -> failure x
transType :: Type -> Result Value
transType x = case x of
  TInt -> failure x
  TBool -> failure x
